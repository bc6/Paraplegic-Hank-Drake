#Embedded file name: c:\depot\games\branches\release\EVE-TRANQUILITY\eve\common\lib\codeGeneration.py
import os
import sys
UE3_VAR_PREFIX = '_XXX_'
OUTPUT_SINGLE_TABLE_COLUMN = '    {columnData[0]:{sizeData[0]}}  {columnData[1]:{sizeData[1]}}  NOT NULL{options},\n'
OUTPUT_SINGLE_SPROC_INPUT = '  @{columnData[0]:{sizeData[0]}}  {columnData[1]}{comma}\n'
ERROR_CANT_OPEN_FILE = "=>  Can't open file {0} for write, did you forget to check it out from perforce?"
INFO_FILE_UNCHANGED = '    Skipped unchanged: {0}'
OUTPUT_FILE_HEADER_COMMENT = '{0} This file is auto-generated by {filename}, do not modify by yourself!!!\n'
IX_COLUMNNAME = 0
IX_DATATYPE = 1
IX_COLUMNOPTIONS = 2
head = os.path.dirname(__file__)
if not len(head):
    head = sys.path[0]
while True:
    oldHead = head
    head, tail = os.path.split(head)
    if head == oldHead:
        head = 'UNABLE TO FIND DB DIRECTORY'
        break
    if os.path.exists(os.path.join(head, 'db')):
        break

SQL_FILES_BASE_PATH = os.path.abspath(os.path.join(head, 'db', 'db-eve', 'schemas'))
SQL_KEYWORDS = ['CHARACTER']

def GetSQLColumnSizeData(columnList):
    sizeData = [0, 0]
    for columnData in columnList:
        for index in range(len(sizeData)):
            sizeData[index] = max(sizeData[index], len(columnData[index]))

    return sizeData


def GetSQLFilename(schemaName, objectName):
    return os.path.join(SQL_FILES_BASE_PATH, schemaName, '{schemaName}.{objectName}.sql'.format(schemaName=schemaName, objectName=objectName))


def MakeLowerTableName(tableName):
    for index, letter in enumerate(tableName):
        if letter != letter.upper():
            break
    else:
        raise RuntimeError("Did not find a lowercase letter in '{0}'.  What are you doing?".format(tableName))

    if index == 1:
        return tableName[0].lower() + tableName[1:]
    if index > 1:
        return tableName[:index - 1].lower() + tableName[index - 1:]
    return tableName


def WriteSQLTableFile(nameData, columnList, sizeData, requestingFile, lineBreaksAfter):
    filename = GetSQLFilename(nameData['schemaName'], nameData['dbTableName'])
    return WriteFileFromFunction(filename, GenerateSQLTableLines, nameData, columnList, sizeData, requestingFile, lineBreaksAfter)


def WriteSQLInsertProcFile(nameData, columnList, sizeData, requestingFile, omitColumns):
    filename = GetSQLFilename(nameData['schemaName'], nameData['insertProcName'])
    return WriteFileFromFunction(filename, GenerateSQLInsertProcLines, nameData, columnList, sizeData, requestingFile, omitColumns)


def WriteSQLUpdateProcFile(nameData, columnList, sizeData, requestingFile, keyColumns):
    filename = GetSQLFilename(nameData['schemaName'], nameData['updateProcName'])
    return WriteFileFromFunction(filename, GenerateSQLUpdateProcLines, nameData, columnList, sizeData, requestingFile, keyColumns)


def WriteSQLSelectProcFile(nameData, columnList, sizeData, requestingFile, keyColumns):
    filename = GetSQLFilename(nameData['schemaName'], nameData['selectProcName'])
    return WriteFileFromFunction(filename, GenerateSQLSelectProcLines, nameData, columnList, sizeData, requestingFile, keyColumns)


def WriteFileFromFunction(filename, function, *args, **kw):
    lines = function(*args, **kw)
    if os.path.exists(filename):
        oldLines = open(filename, 'r').readlines()
        if lines == oldLines:
            print INFO_FILE_UNCHANGED.format(filename)
            return None
        AutoCheckoutMagic(filename)
    try:
        outFile = open(filename, 'w')
    except IOError:
        print ERROR_CANT_OPEN_FILE.format(filename)
        return None

    outFile.writelines(lines)
    outFile.close()
    return os.path.abspath(filename)


def ProcessNames(nameData = None, columnList = None):
    if nameData:
        for key, value in nameData.items():
            if value.upper() in SQL_KEYWORDS:
                nameData[key] = '[' + value + ']'

    if columnList:
        for index, columnData in enumerate(columnList):
            columnName = columnData[IX_COLUMNNAME]
            if columnName.upper() in SQL_KEYWORDS:
                columnList[index] = ('[' + columnName + ']',) + columnData[1:]


def UnProcessNames(nameData = None, columnList = None):
    if nameData:
        for key, value in nameData.items():
            if value[0] == '[':
                nameData[key] = value[1:-1]

    if columnList:
        for index, columnData in enumerate(columnList):
            columnName = columnData[IX_COLUMNNAME]
            if columnName[0] == '[':
                columnList[index] = (columnName[1:-1],) + columnData[1:]


def GenerateSQLTableLines(nameData, columnList, sizeData, requestingFile, lineBreaksAfter):
    ProcessNames(nameData, columnList)
    lines = []
    lines.append(OUTPUT_FILE_HEADER_COMMENT.format('--', filename=requestingFile))
    lines.append('\n')
    lines.append("IF OBJECT_ID('{schemaName}.{dbTableName}') IS NULL\n".format(**nameData))
    lines.append('BEGIN\n')
    lines.append('  CREATE TABLE {schemaName}.{dbTableName}\n'.format(**nameData))
    lines.append('  (\n')
    for index, columnData in enumerate(columnList):
        if index in lineBreaksAfter:
            lines.append('    --\n')
        if len(columnData) <= IX_COLUMNOPTIONS:
            options = ''
        else:
            options = columnData[IX_COLUMNOPTIONS]
            if options:
                options = '  ' + options
            else:
                options = ''
        formatData = {'columnData': columnData,
         'sizeData': sizeData,
         'options': options}
        lines.append(OUTPUT_SINGLE_TABLE_COLUMN.format(**formatData))

    lines.append('\n')
    lines.append('    CONSTRAINT {dbTableName}_PK PRIMARY KEY CLUSTERED ({keyName}),\n'.format(**nameData))
    lines.append('  )\n')
    lines.append('END\n')
    lines.append('GRANT SELECT ON {schemaName}.{dbTableName} TO zzp_gameserver\n'.format(**nameData))
    lines.append('GO\n')
    UnProcessNames(nameData, columnList)
    return lines


def GenerateSQLInsertProcLines(nameData, columnList, sizeData, requestingFile, omitColumns):
    ProcessNames(nameData, columnList)
    lines = []
    lines.append(OUTPUT_FILE_HEADER_COMMENT.format('--', filename=requestingFile))
    lines.append('\n')
    lines.append("IF OBJECT_ID('{schemaName}.{insertProcName}') IS NOT NULL\n".format(**nameData))
    lines.append('  DROP PROCEDURE {schemaName}.{insertProcName}\n'.format(**nameData))
    lines.append('GO\n')
    lines.append('CREATE PROCEDURE {schemaName}.{insertProcName}\n'.format(**nameData))
    hasIdentity = False
    lastColumn = None
    for index, columnData in enumerate(columnList):
        if len(columnData) > IX_COLUMNOPTIONS and 'IDENTITY' in columnData[IX_COLUMNOPTIONS]:
            hasIdentity = True
        if columnData[IX_COLUMNNAME] not in omitColumns:
            lastColumn = index

    if lastColumn is None:
        raise RuntimeError('Cannot generate an INSERT proc if all columns are omitted!')
    for index, columnData in enumerate(columnList):
        if columnData[IX_COLUMNNAME] not in omitColumns:
            formatData = {'columnData': columnData,
             'sizeData': sizeData,
             'comma': '' if index == lastColumn else ','}
            lines.append(OUTPUT_SINGLE_SPROC_INPUT.format(**formatData))

    lines.append('AS\n')
    lines.append('  SET NOCOUNT ON\n')
    lines.append('\n')
    insertBeginning = '  INSERT INTO {schemaName}.{dbTableName}('.format(**nameData)
    columnNameIndent = ' ' * len(insertBeginning)
    firstColumn = True
    for index, columnData in enumerate(columnList):
        if columnData[IX_COLUMNNAME] not in omitColumns:
            prefix = insertBeginning if firstColumn else columnNameIndent
            comma = '' if index == lastColumn else ','
            lines.append('{0}{1}{2}\n'.format(prefix, columnData[IX_COLUMNNAME], comma))
            firstColumn = False

    lines.append(columnNameIndent + ')\n')
    valuesBeginning = '       VALUES ('
    variableNameIndent = ' ' * len(valuesBeginning)
    firstColumn = True
    for index, columnData in enumerate(columnList):
        if columnData[IX_COLUMNNAME] not in omitColumns:
            prefix = valuesBeginning if firstColumn else variableNameIndent
            comma = '' if index == lastColumn else ','
            lines.append('{0}@{1}{2}\n'.format(prefix, columnData[IX_COLUMNNAME], comma))
            firstColumn = False

    lines.append(variableNameIndent + ')\n')
    if hasIdentity:
        lines.append('\n')
        lines.append('  SELECT {keyName} = CONVERT(bigint, SCOPE_IDENTITY())\n'.format(**nameData))
    lines.append('GO\n')
    lines.append('GRANT EXEC ON {schemaName}.{insertProcName} TO zzp_gameserver\n'.format(**nameData))
    lines.append('GO\n')
    UnProcessNames(nameData, columnList)
    return lines


def GenerateSQLUpdateProcLines(nameData, columnList, sizeData, requestingFile, keyColumns):
    ProcessNames(nameData, columnList)
    lines = []
    lines.append(OUTPUT_FILE_HEADER_COMMENT.format('--', filename=requestingFile))
    lines.append('\n')
    lines.append("IF OBJECT_ID('{schemaName}.{updateProcName}') IS NOT NULL\n".format(**nameData))
    lines.append('  DROP PROCEDURE {schemaName}.{updateProcName}\n'.format(**nameData))
    lines.append('GO\n')
    lines.append('CREATE PROCEDURE {schemaName}.{updateProcName}\n'.format(**nameData))
    lastColumn = len(columnList) - 1
    for index, columnData in enumerate(columnList):
        formatData = {'columnData': columnData,
         'sizeData': sizeData,
         'comma': '' if index == lastColumn else ','}
        lines.append(OUTPUT_SINGLE_SPROC_INPUT.format(**formatData))

    lines.append('AS\n')
    lines.append('  SET NOCOUNT ON\n')
    lines.append('\n')
    lastNonKeyColumn = None
    lastKeyColumn = None
    for index, columnData in enumerate(columnList):
        if columnData[IX_COLUMNNAME] in keyColumns:
            lastKeyColumn = index
        else:
            lastNonKeyColumn = index

    if lastNonKeyColumn is None or lastKeyColumn is None:
        raise RuntimeError('You cannot create an UPDATE proc unless there are both key and non-key columns!')
    lines.append('  UPDATE {schemaName}.{dbTableName}\n'.format(**nameData))
    setClauseBeginning = '     SET '
    columnNameIndent = ' ' * len(setClauseBeginning)
    firstColumn = True
    for index, columnData in enumerate(columnList):
        if columnData[IX_COLUMNNAME] not in keyColumns:
            prefix = setClauseBeginning if firstColumn else columnNameIndent
            comma = '' if index == lastNonKeyColumn else ','
            lines.append('{0}{1} = @{1}{2}\n'.format(prefix, columnData[IX_COLUMNNAME], comma))
            firstColumn = False

    whereClauseBeginning = '   WHERE '
    columnNameIndent = ' ' * len(whereClauseBeginning)
    firstColumn = True
    for index, columnData in enumerate(columnList):
        if columnData[IX_COLUMNNAME] in keyColumns:
            prefix = whereClauseBeginning if firstColumn else columnNameIndent
            comma = '' if index == lastKeyColumn else ' AND'
            lines.append('{0}{1} = @{1}{2}\n'.format(prefix, columnData[IX_COLUMNNAME], comma))
            firstColumn = False

    lines.append('\n')
    lines.append('  RETURN @@ROWCOUNT\n')
    lines.append('GO\n')
    lines.append('GRANT EXEC ON {schemaName}.{updateProcName} TO zzp_gameserver\n'.format(**nameData))
    lines.append('GO\n')
    UnProcessNames(nameData, columnList)
    return lines


def GenerateSQLSelectProcLines(nameData, columnList, sizeData, requestingFile, keyColumns):
    ProcessNames(nameData, columnList)
    lines = []
    AddSQLProcHeader(lines, 'select', nameData, requestingFile)
    lastNonKeyColumn = None
    lastKeyColumn = None
    for index, columnData in enumerate(columnList):
        if columnData[IX_COLUMNNAME] in keyColumns:
            lastKeyColumn = index
        else:
            lastNonKeyColumn = index

    if lastNonKeyColumn is None or lastKeyColumn is None:
        raise RuntimeError('You cannot create an UPDATE proc unless there are both key and non-key columns!')
    for index, columnData in enumerate(columnList):
        if columnData[IX_COLUMNNAME] in keyColumns:
            formatData = {'columnData': columnData,
             'sizeData': sizeData,
             'comma': '' if index == lastKeyColumn else ','}
            lines.append(OUTPUT_SINGLE_SPROC_INPUT.format(**formatData))

    lines.append('AS\n')
    lines.append('  SET NOCOUNT ON\n')
    lines.append('\n')
    selectClauseBeginning = '  SELECT '
    columnNameIndent = ' ' * len(selectClauseBeginning)
    firstColumn = True
    for index, columnData in enumerate(columnList):
        if columnData[IX_COLUMNNAME] not in keyColumns:
            prefix = selectClauseBeginning if firstColumn else columnNameIndent
            comma = '' if index == lastNonKeyColumn else ','
            lines.append('{0}{1}{2}\n'.format(prefix, columnData[IX_COLUMNNAME], comma))
            firstColumn = False

    lines.append('    FROM {schemaName}.{dbTableName}\n'.format(**nameData))
    whereClauseBeginning = '   WHERE '
    columnNameIndent = ' ' * len(whereClauseBeginning)
    firstColumn = True
    for index, columnData in enumerate(columnList):
        if columnData[IX_COLUMNNAME] in keyColumns:
            prefix = whereClauseBeginning if firstColumn else columnNameIndent
            comma = '' if index == lastKeyColumn else ' AND'
            lines.append('{0}{1} = @{1}{2}\n'.format(prefix, columnData[IX_COLUMNNAME], comma))
            firstColumn = False

    lines.append('GO\n')
    lines.append('GRANT EXEC ON {schemaName}.{selectProcName} TO zzp_gameserver\n'.format(**nameData))
    lines.append('GO\n')
    UnProcessNames(nameData, columnList)
    return lines


def AddSQLProcHeader(lines, procType, nameData, requestingFile):
    procName = nameData[procType.lower() + 'ProcName']
    lines.append(OUTPUT_FILE_HEADER_COMMENT.format('--', filename=requestingFile))
    lines.append('\n')
    lines.append("IF OBJECT_ID('{schemaName}.{procName}') IS NOT NULL\n".format(procName=procName, **nameData))
    lines.append('  DROP PROCEDURE {schemaName}.{procName}\n'.format(procName=procName, **nameData))
    lines.append('GO\n')
    lines.append('CREATE PROCEDURE {schemaName}.{procName}\n'.format(procName=procName, **nameData))


def AutoCheckoutMagic(fileName):
    import subprocess
    try:
        p = subprocess.Popen('p4 edit %s' % fileName, stdout=subprocess.PIPE, creationflags=134217728)
    except Exception:
        return

    stdoutData, stderrData = p.communicate()
    print stdoutData


def SetIndent(text, tabs = 0, spaces = 0):
    realIndent = '\t' * tabs + ' ' * spaces
    artificialIndent = len(text) - len(text.lstrip())
    text = text.split('\n')
    text = [ realIndent + line[artificialIndent:] for line in text ]
    text = '\n'.join(text)
    return text